---
layout: post
title: TIL_20171218 ~
tags: TIL lazy extension protocol pragma_mark
categories: TIL
---

2017.12.18
TODO
- JSON step2 피드백 처리
- 정규표현식 공부
  - 손에 잡히는 정규표현식 읽기
  - regexOne에서 연습

## JSON Parser 만들기 참고 사이트
* 문법검사

  https://jsonlint.com/

* JSON 배우기 및 확인

  https://regexr.com/

  https://regexone.com/lesson/capturing_groups
  http://www.rubular.com/

  https://regex101.com/

TIL
- `lazy` 지연 저장형 프로퍼티
- JSON step2 피드백 처리
  - extension에 protocol적용 : Array와 Dictionary를 ConvertTarget 프로토콜로 추상화하고, convertValues() 함수를 제거 : 하는 일은 똑같고, 리턴값을 이후에 처리하는 메소드도 똑같은 두 함수가 있는데, 리턴타입이 달랐다. 이를 하나의 프로토콜로 추상화하기위해서 원래있던 swift의 타입에 extension을 적용해서 프로토콜로 추상화했다. > 추상화로 인해서 중복되는 메소드도 줄이거나 private으로 감출 수 있었고, 과도하게 쓰인 switch-case문을 줄일 수 있었다.
  - extension의 사용 (pragma mark 사용) : 한 객체의 코드가 너무 길어지면 가독성을 위해서 extension을 사용했었는데, extension은 이렇게 의미없이 사용하는게 아니라고 함. 의미없이 사용된 extension은 제거하고 `// MARK:` 주석을 사용했다. 스위프트에는 MARK말고도 특별한 주석이 있다. pragma mark는 Objective-C에서 사용되는 구문이다. (스위프트에서는`// MARK:`, `// TODO:` , `// FIXME:` 만 사용 가능하다.) 이런 키워드들을 사용해서 주석을 달면 Quick jump bar에서 책갈피처럼 주석내용을 볼 수 있다! [참고사이트1](https://stackoverflow.com/questions/35963128/swift-understanding-mark) [참고사이트2](https://littlebitesofcocoa.com/207-annotating-swift-with-marks-todo-s-and-fixme-s)

2017.12.19
TODO
- JSON step2 피드백 처리
- JSON step3 시작
- 정규표현식 공부
  - regexOne에서 연습
  - InputView - GrammarChecker - ParseTargetFactory 설계
    - GrammarChecker를 InputView와 ParseTargetFactory사이 흐름에 위치
    - GrammarChecker에 정규표현식 적용
    - (GrammarChecker에 에러처리 적용) - 오늘 안될지도

2017.12.21
TODO
- git 저장소 origin확인 - 리모트에 스텝브랜치만 푸시되어있고 아이디 브랜치는 최신 상태가 아님ㅠㅠ
- 정규식 적용한 step3 진행
  - 찾아낸 정규식을 활용할 수 있는 메소드 찾고 기존 로직이랑 연결시키기
  - object안에 있는 Array를 검사하고 형변환하는것 추가
  - `[]`이면서 밸류가 딕셔너리 형태로 있는 것 걸러내기

1. git json저장소 youth브랜치확인하기. 오리진이 어디로 됐는지, 지금 스텝브랜치만 나눠져있곤 리모트의 내 아이디 브랜치에 하나도 푸시가 안돼어있음
2. 정규식 적용한 json step3 빨리 진행. 정규식 클래스 이용해서 맞는 패턴 찾아내고 빠르게 기존 로직이랑 연결시키기. 오브젝트일때 배열 요소 검사하고 형변환하는거 추가하기. 오브젝트괄호이면서 딕셔너ㅣ 형태로 들어있는거 인거 걸러내기

TIL
- git은 먼저 로컬 youth27브랜치에서 status를 보니까 pull받을게 남아있다길래 pull했더니 싱크가 맞았고, 그 상태에서 리모트의 youth27브랜치로 push하니 싱크가 맞았다. (현재 코드스쿼드와 youth27저장소 모두 step2까지 업데이트된 상황) 그 이후로 똑같이 step3 브랜치 따서 작업하니 문제 없었다. 생각보다 엄청 쉽게 해결~
- 정규식을선언한 이후에 그 클래스에서 사용하는 방법을 몰랐었는데, 검색으로 유추해서 패턴과 일치한 문자열들을 [String]으로 리턴해주는 matches함수가 있었다. matches에서 리턴한 값을 value마다 하나씩 검사해서 맞는 형식인지 아닌지 검사, 에러처리하는 방식으로 해결했다.
- 정규식 선언 이후에 Parser가 간단해졌다.
- 카운팅하는 객체, Data Converting하는 객체에 Array 케이스를 추가해서 해결!

```Swift

 중괄호 한 세트 안의 문자 : \{(.*?)\}
 따옴표 한 세트 안의 문자 : \"(.+?)\"

 Array : true|false|\".+?\"|\d+|\{.+?\}
 Object : (\".+?\")\:(true|false|\".+?\"|\d+|\[.+?\])
 이 오브젝트에서 1 depth 정도 더 들어가서 ex) object의 요소를ㅡ"dee":234 이렇게 떼어놨으면, 여기서 "ㅇㅇㅇ":ㅁㅁㅁ 인지 검사를 해야하는 것. 정규식 한 줄로 오브젝트 형태 체크랑, 그 안의 각각 요소가 "key":value 형태로 잘 들어왔는지 체크하기가 힘드니까. 차라리 전체에서 잘라진 작은 덩어리를 검사하는 다른 정규식을 하나 더 만들든가, 로직으로 처리하든가 해서 딕셔너리 형태가 맞는지 검사하는게 더 편한 방법일듯.

 [true,"sdfe",false,123,{"dee":234,"ss":false,"er":"wert"},"rr"]
 {"dee":234,"ss":false,"er":"wert"}
 {"dee":234,"ss":false,"er":["hana","hayul","haun"]}
 ["dee":234,"ss":false]
{"d":"e","t":12,"rr":false,"array":[12,true]}

 */

/*
 GrammarChecker에서
 1. 전체 format 검사하고 내부 값 String배열로 만들기
 2. String배열의 각 value를 하나씩 검사하는 것 만들기 (Array형태일때 딕셔너리가 들어오면 안되는것")
*/


    func matches(for regex: String, in text: String) -> [String] {

        do {
            let regex = try NSRegularExpression(pattern: regex)
            let nsString = text as NSString
            let results = regex.matches(in: text, range: NSRange(location: 0, length: nsString.length))
            return results.map { nsString.substring(with: $0.range)}
        } catch let error {
            print("invalid regex: \(error.localizedDescription)")
            return []
        }
    }
    let testString = "[true,false,123,\"esdf\",{\"dee\":234,\"ss\":false,\"er\":\"wert\"},\"rr\"]"
    let arrayformat = "true|false|[0-9]+|\\{.+?\\}"
    let result = matches(for: arrayformat, in: testString)
    print(result)


```
