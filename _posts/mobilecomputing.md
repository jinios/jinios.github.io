### 모바일컴퓨팅
모바일 디바이스는 계속 새로 생겨나고있다. 개발자의 로드맵으로서는 향후 여러 모바일 디바이스를 활용하고 개발 할 수 있음
'네트워크에 연결되어 사용할 수 있는 컴퓨팅환경'을 통틀어 모바일컴퓨팅이라고 한다!
모든 물건들은 점점 connectivity와 mobility가 점점 좋아지는 추세로 가고있다.
그러면서 허브 역할을 하는 디바이스 생김 (아이폰 - 애플워치의 허브, 홈팟 등등)
아이폰 앱만 개발한다고 생각하지 말고, 그 뿐만이아니라 새로운 기술력을 바탕으로 한 회사도 많다! 시야를 넓히기!

## 클로저 캡쳐와 순환참조
- 오늘 데일리미팅에서 클로저 캡쳐 / 순환참조의 고리를 끊기위해 클로저 내부에서 사용되는 값을 캡쳐할 필요가 있다. (주로 `self`키워드에)
- 클로저를 만든 객체 내부에 있는 그 클로저에서 그 객체를 사용해야하는데, 그 객체가 클로저를 통과하면서 없어져야하는데 그 객체를 캡쳐하지않고 참조만 해서 쓰면 객체가 없어지지않고 순환참조되어버림
- 예를들어, 어떤 뷰컨트롤러 객체가 클로저를 통과하면서 어떤 애니메이션 작업을 통해서 해당 뷰가 없어져야하는데 (다음 화면이 나온다거나 하면서) 만약 클로저 내부에서 self.객체를 캡쳐해서 쓰지않고 참조해서 쓰면 클로저 안에서 로직이 동작하면서 뷰컨트롤러 스스로의 그 객체가 계속 순환참조되어버려서 없어지지 않는 현상.
- https://outofbedlam.github.io/swift/2016/01/31/Swift-ARC-Closure-weakself/
- 순환참조 retain cycle https://medium.com/mackmobile/avoiding-retain-cycles-in-swift-7b08d50fe3ef

***
3/20 레벨3 강의


### 생성자 상속과 재정의
생성자: 스위프트에서도 까다롭고 어려운 문법규칙 중 하나
자바나 c++같은 언어에서는 constructor라는 이름으로 많이 쓴다.
객체지향으로 넘어오면서 객체를 생성하고 나면 의미없는값이더라도 초깃값을 넣어주는게 중요했다. (쓰레기값이 들어가지 않도록)
생성자가 있으면 항상 소멸자도 있었는데,
객체 안에서 객체를 만드는 경우, 내부에서 만들어서 변수에 대입된 객체는 소멸자를 통해서 해제되도록하자.

스위프트의 생성자와 소멸자
init() <-> deinit()

지정초기화 - Designated메소드는 무조건 하나 이상은 있어야함 객체를 만들려면 무조건 값이 다 있어야 하는 생성자(자판기에 여러 매개변수 값을 넣어서 음료 하나를 만들때의 init()) 디테일한 값들이 다 들어있음

convenience 메소드 - Designated를 호출하도록 만들어서 객체 만들때 좀 더 편하게 하는것. convenience안에서 Designated를 호출

### main.swift
원래 \@UIApplicationMain에서 main을 만든다.
UIApplicationMain - UI 앱을 만드는 함수
appDelegate

UIKit에 있는 클래스는 지정초기화메소드를 사용하지 않으면 아예 뜨지 않는 경우가 많다. subclass에서만 편의 메소드`init()`를 쓸 수 있다

### outlet
서브클래싱을 이용해서 속성을 넣어준다. 해당 UI요소가 뜨는 시기적인(?) override클래스 내부에 아웃렛에 적용되어야할 속성 코드를 넣어준다. (extension을 하거나 서브클래싱을 하거나 하는데 둘 중에어떤 것에 기ㅂ준을 둘지 자신만의 기준을 둔다.)

UIView ㄴ- 컨텐츠를 그리는데 집중
responder - 뷰 요소들은 responder를 상속받아서 구현되어있다. 이벤트를 구성하는 responder chain - linked list처럼 다음에 응답할 애 다음에 응답할 애 다음 다음 그다음...

FirstResponder
스토리보드에서 ui요소를 FirstResponder아이콘이랑 잇기 - 직접 메소드와 잇는것이 아니라 그냥 가장 처음에 응답하는애랑 연결해! 이거랑 비슷
그러면 responder chain중에서 가장 처음에 event가 감지된 곳에서 함수가 호출된다.
Hit-Test - 불투명해야 터치이벤트가 적용됨

main run loop - 메인에서 무한루프 돌면서 이벤트 처리


### 3/29 강의
컴파일에러와 링크에러
한 swift파일에 바이너리 파일이 만들어진다
CPU
$ gcc main.c -S : `-S`명령이 있으면 장비의 명령에 맞는 어셈블리가 나옴
  - 맥에서 작업하지만(host) 작업은 폰에서 함

시뮬레이터 : 호스트용 아키텍쳐에서 (타겟용대로)실행될 수 있도록 함. 호스트에서 실제 올릴 디바이스에 올린것처럼 실행해볼수있도록 미리 빌드함. 다만 호스트는 여전히 맥이기때문에 폰 디바이스에서 돌리는것과는 차이가 있을 수 있음
호스트에서 타겟과 비슷한 환경에서 돌아가도록 해줌

$ gcc main.c -S -arch armv7
애뮬레이터 : 타겟용 아키텍쳐에서 실행될 수 있도록 빌드함.
(참고로 안드로이드에서 시뮬레이터라고 하는것은 다 애뮬레이터임. ios의 시뮬레이터는 시뮬레이터)

$ gcc -o sum sum.o main.o
두 c파일의 오브젝트 파일을 각각 만든다음에 sum이라는 이름으로 실행파일을 만듦 (각각 컴파일러가 object만들고 링크해줌)

타겟 환경에서 빌드해주기위해서 크로스컴파일러
컴파일 할때는 프레임워크가 없으면 컴파일도 안되는데, 그러면 프레임워크를 넣어주면 되고, 컴파일 후 오브젝트파일로 만들고 각 오브젝트 파일을 링크를 해줘서 실행파일을 만들어주고 등등등 이지만 이 모든걸 엑스코드가 해주고있음


### 4/9강의 함수형프로그래밍
스위프트의 클로저에서 밖엥있는변수를 참조할때는 reference타입으로 참조한다.
변수를 선언할때 var보다 let을 먼저 쓰는게 (나중에 바꾸고싶으면 var로 변경) 좋다.
오버플로우연산자 - 오버플로우가 발생할수 있는 결과가 나올 연산에 써서 오버플로우 값이 결과로 나와도 프로그램이 종료되지 않게함

#### custom operator

precedencegroup: 컴파일러에게 주는 옵션같은 것
associativity : left 왼쪽에 연관된 값에 기준해서 처리해라
higherThan : 처리 중요도를 정해줌

오퍼레이터를 만들때 클로저로 매개변수로 넘기면서 다음에 나온 값을 또 다음에 나오는 함수에 넘어가는것이 자연스러워보이게끔! (선언적으로 보이게 해서 읽기도 쉬워짐)
대신에 똑같은 오퍼레이터를 써서 계속 함수에 이전함수결과값을 넘기고 넘기고 하려면 매개변수가 중요함
이런 매개변수를 맞춰줘야하는 것 때문에 매개변수의 제네릭으로 만들 수 있다.


#### 4/12 강의
View관련 커스텀뷰 추가!
UIView상속받아서 코코아터치클래스 만듦
draw함수에 super.draw()
스토리보드에서 뷰 컨트롤러가 가진 뷰의 타입을 오른쪽 탭 custom class에서 class에 내가 추가한 커스텀뷰 클래스 이름 입력하여 연결
인터페이스빌더에서 custom클래스로 지정한 뷰는 required init?(coder aDecoder:)가 호출된다.
코드로 addSubVIew한 뷰는 override init이 호출된다.
만약 자판기에서 내가 원하던 방법으로 하려고했으면 override init에 세팅하는 코드를 넣었어야 될 것 같다.
만약에 어디서 호출될지 모르면 awakeFromNib과 두 convenience init에 설정하는 코드를 넣어주면 된다.

UIView는 layer를 하나 가지고있다. 뷰 보다 더 가벼운 화면 처리하는 단위. 그림을그리거나 그림자를 넣는 가벼운 용도로 사용되며 뷰 하나에 여러 레이어를 쌓아서 그림을 그릴 수 있지만 각각 이벤트를 주거나 할 수는 없고 디버깅할때 z축으로 돌려보더라도 뷰가 하나기때문에 그냥 한장의 뷰로 보인다.
알파값이 0이되면 그 뷰는 없는 거! / clear색이면 투명하지만 그 area에는 뷰가 존재하는데, 알파값이면 그 뷰는 존재하지 않는것임

shapeLayer- 코어그래픽스처럼 그림 그릴 수 있음
