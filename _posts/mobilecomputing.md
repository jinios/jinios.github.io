### 모바일컴퓨팅
모바일 디바이스는 계속 새로 생겨나고있다. 개발자의 로드맵으로서는 향후 여러 모바일 디바이스를 활용하고 개발 할 수 있음
'네트워크에 연결되어 사용할 수 있는 컴퓨팅환경'을 통틀어 모바일컴퓨팅이라고 한다!
모든 물건들은 점점 connectivity와 mobility가 점점 좋아지는 추세로 가고있다.
그러면서 허브 역할을 하는 디바이스 생김 (아이폰 - 애플워치의 허브, 홈팟 등등)
아이폰 앱만 개발한다고 생각하지 말고, 그 뿐만이아니라 새로운 기술력을 바탕으로 한 회사도 많다! 시야를 넓히기!

## 클로저 캡쳐와 순환참조
- 오늘 데일리미팅에서 클로저 캡쳐 / 순환참조의 고리를 끊기위해 클로저 내부에서 사용되는 값을 캡쳐할 필요가 있다. (주로 `self`키워드에)
- 클로저를 만든 객체 내부에 있는 그 클로저에서 그 객체를 사용해야하는데, 그 객체가 클로저를 통과하면서 없어져야하는데 그 객체를 캡쳐하지않고 참조만 해서 쓰면 객체가 없어지지않고 순환참조되어버림
- 예를들어, 어떤 뷰컨트롤러 객체가 클로저를 통과하면서 어떤 애니메이션 작업을 통해서 해당 뷰가 없어져야하는데 (다음 화면이 나온다거나 하면서) 만약 클로저 내부에서 self.객체를 캡쳐해서 쓰지않고 참조해서 쓰면 클로저 안에서 로직이 동작하면서 뷰컨트롤러 스스로의 그 객체가 계속 순환참조되어버려서 없어지지 않는 현상.
- https://outofbedlam.github.io/swift/2016/01/31/Swift-ARC-Closure-weakself/
- 순환참조 retain cycle https://medium.com/mackmobile/avoiding-retain-cycles-in-swift-7b08d50fe3ef

***
3/20 레벨3 강의


### 생성자 상속과 재정의
생성자: 스위프트에서도 까다롭고 어려운 문법규칙 중 하나
자바나 c++같은 언어에서는 constructor라는 이름으로 많이 쓴다.
객체지향으로 넘어오면서 객체를 생성하고 나면 의미없는값이더라도 초깃값을 넣어주는게 중요했다. (쓰레기값이 들어가지 않도록)
생성자가 있으면 항상 소멸자도 있었는데,
객체 안에서 객체를 만드는 경우, 내부에서 만들어서 변수에 대입된 객체는 소멸자를 통해서 해제되도록하자.

스위프트의 생성자와 소멸자
init() <-> deinit()

지정초기화 - Designated메소드는 무조건 하나 이상은 있어야함 객체를 만들려면 무조건 값이 다 있어야 하는 생성자(자판기에 여러 매개변수 값을 넣어서 음료 하나를 만들때의 init()) 디테일한 값들이 다 들어있음

convenience 메소드 - Designated를 호출하도록 만들어서 객체 만들때 좀 더 편하게 하는것. convenience안에서 Designated를 호출

### main.swift
원래 \@UIApplicationMain에서 main을 만든다.
UIApplicationMain - UI 앱을 만드는 함수
appDelegate

UIKit에 있는 클래스는 지정초기화메소드를 사용하지 않으면 아예 뜨지 않는 경우가 많다. subclass에서만 편의 메소드`init()`를 쓸 수 있다

### outlet
서브클래싱을 이용해서 속성을 넣어준다. 해당 UI요소가 뜨는 시기적인(?) override클래스 내부에 아웃렛에 적용되어야할 속성 코드를 넣어준다. (extension을 하거나 서브클래싱을 하거나 하는데 둘 중에어떤 것에 기ㅂ준을 둘지 자신만의 기준을 둔다.)

UIView ㄴ- 컨텐츠를 그리는데 집중
responder - 뷰 요소들은 responder를 상속받아서 구현되어있다. 이벤트를 구성하는 responder chain - linked list처럼 다음에 응답할 애 다음에 응답할 애 다음 다음 그다음...

FirstResponder
스토리보드에서 ui요소를 FirstResponder아이콘이랑 잇기 - 직접 메소드와 잇는것이 아니라 그냥 가장 처음에 응답하는애랑 연결해! 이거랑 비슷
그러면 responder chain중에서 가장 처음에 event가 감지된 곳에서 함수가 호출된다.
Hit-Test - 불투명해야 터치이벤트가 적용됨

main run loop - 메인에서 무한루프 돌면서 이벤트 처리


### 3/29 강의
컴파일에러와 링크에러
한 swift파일에 바이너리 파일이 만들어진다
CPU
$ gcc main.c -S : `-S`명령이 있으면 장비의 명령에 맞는 어셈블리가 나옴
  - 맥에서 작업하지만(host) 작업은 폰에서 함

시뮬레이터 : 호스트용 아키텍쳐에서 (타겟용대로)실행될 수 있도록 함. 호스트에서 실제 올릴 디바이스에 올린것처럼 실행해볼수있도록 미리 빌드함. 다만 호스트는 여전히 맥이기때문에 폰 디바이스에서 돌리는것과는 차이가 있을 수 있음
호스트에서 타겟과 비슷한 환경에서 돌아가도록 해줌

$ gcc main.c -S -arch armv7
애뮬레이터 : 타겟용 아키텍쳐에서 실행될 수 있도록 빌드함.
(참고로 안드로이드에서 시뮬레이터라고 하는것은 다 애뮬레이터임. ios의 시뮬레이터는 시뮬레이터)

$ gcc -o sum sum.o main.o
두 c파일의 오브젝트 파일을 각각 만든다음에 sum이라는 이름으로 실행파일을 만듦 (각각 컴파일러가 object만들고 링크해줌)

타겟 환경에서 빌드해주기위해서 크로스컴파일러
컴파일 할때는 프레임워크가 없으면 컴파일도 안되는데, 그러면 프레임워크를 넣어주면 되고, 컴파일 후 오브젝트파일로 만들고 각 오브젝트 파일을 링크를 해줘서 실행파일을 만들어주고 등등등 이지만 이 모든걸 엑스코드가 해주고있음


### 4/9강의 함수형프로그래밍
스위프트의 클로저에서 밖엥있는변수를 참조할때는 reference타입으로 참조한다.
변수를 선언할때 var보다 let을 먼저 쓰는게 (나중에 바꾸고싶으면 var로 변경) 좋다.
오버플로우연산자 - 오버플로우가 발생할수 있는 결과가 나올 연산에 써서 오버플로우 값이 결과로 나와도 프로그램이 종료되지 않게함

#### custom operator
precedencegroup: 컴파일러에게 주는 옵션같은 것
associativity : left 왼쪽에 연관된 값에 기준해서 처리해라
higherThan : 처리 중요도를 정해줌

오퍼레이터를 만들때 클로저로 매개변수로 넘기면서 다음에 나온 값을 또 다음에 나오는 함수에 넘어가는것이 자연스러워보이게끔! (선언적으로 보이게 해서 읽기도 쉬워짐)
대신에 똑같은 오퍼레이터를 써서 계속 함수에 이전함수결과값을 넘기고 넘기고 하려면 매개변수가 중요함
이런 매개변수를 맞춰줘야하는 것 때문에 매개변수의 제네릭으로 만들 수 있다.
https://gist.github.com/godrm/7f5b8d024e866ab8aa6ef152da693862
http://public.codesquad.kr/jk/Feedback-20180409.pdf
http://jasonlarsen.me/2015/05/23/pipes.html



#### 4/12 강의
View관련 커스텀뷰 추가!
UIView상속받아서 코코아터치클래스 만듦
draw함수에 super.draw()
스토리보드에서 뷰 컨트롤러가 가진 뷰의 타입을 오른쪽 탭 custom class에서 class에 내가 추가한 커스텀뷰 클래스 이름 입력하여 연결
인터페이스빌더에서 custom클래스로 지정한 뷰는 required init?(coder aDecoder:)가 호출된다.
코드로 addSubVIew한 뷰는 override init이 호출된다.
만약 자판기에서 내가 원하던 방법으로 하려고했으면 override init에 세팅하는 코드를 넣었어야 될 것 같다.
만약에 어디서 호출될지 모르면 awakeFromNib과 두 convenience init에 설정하는 코드를 넣어주면 된다.

UIView는 layer를 하나 가지고있다. 뷰 보다 더 가벼운 화면 처리하는 단위. 그림을그리거나 그림자를 넣는 가벼운 용도로 사용되며 뷰 하나에 여러 레이어를 쌓아서 그림을 그릴 수 있지만 각각 이벤트를 주거나 할 수는 없고 디버깅할때 z축으로 돌려보더라도 뷰가 하나기때문에 그냥 한장의 뷰로 보인다.
알파값이 0이되면 그 뷰는 없는 거! / clear색이면 투명하지만 그 area에는 뷰가 존재하는데, 알파값이면 그 뷰는 존재하지 않는것임

shapeLayer- 코어그래픽스처럼 그림 그릴 수 있음


### 4.17강의

MVC 설계패턴!은 구현코드와는 아무 상관없음(구현할때는 디자인패턴)
MVP패턴에도 컨트롤러가 존재할 수 있다. (아예 없진 않음, 컨트롤러의 역할을 나눴다고 보면됨)
iOS의 MVC는 실제로 V가 VC에 포함되어있기때문에 관계가 모호하고, 뷰 컨트롤러(VC)의 역할이 굉장히 거대해보이기도 한다.

프리젠터와 컨트롤러의 차이
- PV의 관계: 의존성 역전. View가 Presenter를 프로토콜로만 알고있고 결국엔 컨트롤러가 뷰에게 `너의 프리젠터는 이거야`라고 지정해줄순있음


### Bitmap
사진을 하나하나구성하는 요소 pixel 사진을 2차원적으로 저장하는 비트맵
0~255까지
RGB와 CMYK는 상대적이므로 서로 계산이 가능하다.
보통 모니터에서 표현은 RGB, 출력할때는 CMYK로 표현된다.
R,G,B 8비트 256단계로 컬러를 표현 (컬러스페이스)
아이폰은 표현할수있는 더 컬러가 많아졌다

Animation
속성을 바꾸면 그냥 다시 그리는 것이지만, animation을 하면 클로저 밖의 캡쳐된 속성을 클로저 내부에 있는 값으로 n등분해서 그려줌. 그러면서 주우욱 움직이는 것으로 보일 수 있음!

transform - 원래 속성이 바뀐게 아니고 identity를 넣어주면 undo를 간단히 할 수 있다. animation은 속성을 바꿔버리는것(CGAffineTransform)
scale같은 효과는 두 방법 모두 보이는 것은 같다.

디스플레이링크는 초당 60번정도불림

물리 엔진


### 객체 추상화하는법
- 객체가 가진 값을 외부에서는 몰라야하는 것은 기본 (private)
- 프로토콜과 클래스상속 추상화의 차이
  - 프로토콜 - 메소드 추상화 - 속성에 직접 접근할 수 없어야함
  - 클래스 상속 - 프로퍼티 추상화


#### 2018.04.27 강의 앱스토어 등록 관련
푸시인증서는 미리 준비해야하고 푸시인증서는 서버에도 등록해놔야함
adhoc 배포때는 디바이스 번호를 꼭 등록해야
아카이브를해야 스토어에 올릴 준비가 되는것
디버그게이지
instruments에서 그래프랑 통계를 보면서 메모리를 많이쓰는부분(이 아이콘을 누르면 메모리가 쭉 올라가지않는지) 등을 체크할 수 있음
instruments항목에 바로 추가되지 않는 항목들은 deferred 모드 항목들. 앱을 샘플링할때조차 그 앱의 성능에 영향을 줄거같으면 기록만 해놨다가 나중에 한꺼번에 따로 보여주는 검사 항목임


### View와 ViewModel
- View가 protocol을 따르는 객체를 속성으로 갖고있음
- 그 속성은 어떤 객체가 주든 상관없음(VC가될수도, AppDelegate가 될수도있음
- view가 데이터를 직접 가지고(ex. [Beverage]? 혹은 [Card]) 그 인덱스나 밸류값들을 구해서 계산하는게 아니라,
- view가 가진 객체(프로토콜)에게 계속 물어봐서 스스로 그려야함
- 예를들어 pieGraphView가 var history = [Beverage]?를 가지고 총 인덱스 수, 각 밸류의 수, 각도 등을 다 계산해서 그릴것이 아니라
- history = [Beverage]를 가진 객체가 파이그래프를 그리기위해 필요한 각도, 라디안, 총 어레이 카운트 등을 계산해서 가지고있고, pieGraphView가 하나 그릴때마다 객체에 물어보고 스스로 그리는 방식을 써야함. 이때 그린다는 의미는 그릴때의 필요한 정보는(배열의 인덱스, 총 개수, 각 배열의 수 등)view가 하나도 직접 갖고있지않고, 오직 history객체에서 넘겨주는 값을 통해서 draw(add view)만 한다는 뜻이다.
- 여기서 history를 가진 객체는 pieGraphView의 뷰 모델이라고 할 수 있다.


Objective-C
C계열 언어들은 헤더파일이 있다. main에 이런 메소드들이있으니까 보고 써 와 같은 서머리느낌. main에 있는 함수들중에서 public한것만 헤더파일의 @interface 와 @end 사이에 쓴다.
main에서는 헤더를 import해서 쓴다.
import하면 헤더가 복사된

Computer science에서의 atomic - 어떠한 변수나 값에 접근하는 것이 한번에 하나만 되게하는 것이 atomic하다고 말할수있음
누가 쓰고있을때 다른 것이 접근하지 못하게 하는 것(값이 순수하게 유지될 수 있도록 보장)
여러 스레드에서 동시에 하나의 값에 접근하고 사용하는 것(read, write)을 보장하게 하는 것 - atomic
non-atomic 그 반대


Concurrent Programming강의 4/26
https://medium.com/flawless-app-stories/basics-of-parallel-programming-with-swift-93fee8425287

병렬적, 동시성
Parallel - 일을 할 수 있는 worker가 물리적으로 여러개가 있냐 worker들끼리 다 독립적으로 일 할수있어야함 (GPU. 연산에 더 적합)
Concurrent - 논리적으로 작업단위를 나눠서 여러번 처리하는 것이 Concurrent. Concurrent에서 worker는 하나일 수 있다. 하지만 그 작업을 얾마나 나눠서 처리하느냐가 포인트 (CPU. 조건을 판단하고 논리적으로 실행하는 프로그램에 더 적합)
CPU - 프로세서. 이 안에서 논리적인 작업을 하기위해서 쓰레드를만들어서 작업
쓰레드는 맥락(context)을 계속 기억하고있어야 정확히 일을 할 수 있다. 각각의 context가 각각의메모리영역을 갖고, 어디를 실행해야되는지 알고있음
CPU가 많아지면서 앱을 어떤 cpu에서 실행해야할까?가 쟁점이 됨

GCD
운영체제가 알아서 효율적으로 thread를 관리하고, 개발자들은 thread에게 넘길수있는 더 작은 작업단위를(block-클로저단위) 만들어서 thread에 넘기는 형식으로 발전됨 작업을 관리하는 queue에 넣어놓으면 os에의해서 thread가 알아서 작업 처리

thread pool 미리 운영체제가 최적화된 쓰레드풀을미리만들어놓음 - 대기하고있는 객체들을 하나씩 꺼내서 일을 하나씩 주는 형태

Locking
동일한 변수에 여러 쓰레드가 동시에 참조할때 그 부분은 critical section이라고하는데, 이 부분을 atomic하게만들어주기위해 locking하여 동시에 실행되는 것을 막아주는 기능
mutex - mutual execution. 깃발(변수)이 한개 먼저잡은애(worker)가 깃발을 다쓰고 놔둬야 그다음애가 깃발을쓸수있음
semaphor- 리소스가 여러개인경우. (배열처럼, n번째에 온 사람이 n번째의 배열을 쓸수있도록 하는 경우)동시에 쓸수있는사람이 셋인경우 넷인경우 등

멀티쓰레드에서는 데드락을 조심 - 클로저 안에서 다른 클로저가 끝나기를 기다리는 상태

### 클로저 unowned self
- 강한 순환 참조가 발생되는 곳에서는 변수 선언시에 weak이나 unowned를 명시하여 약한 참조가 발생하도록 한다.
- 강한 순환 참조: 클래스가 다른 인스턴스를 프로퍼티로 갖게되는경우, 만약 두 인스턴스가 서로를 프로퍼티로 참조하게되면 상호간에 강한 참조순환이 발생하게된다.
- weak: 변수가 가리키는 대상이 더 이상 존재하지 않을 때 자동으로 nil로 인식되는 저장타입의 변수이다. 따라서 외부로부터 해당 값이 파괴될 때를 상정하여 옵셔널 타입으로 지정하여야 한다. 또한 이는 대상에 대해 참조 수를 올리지 않는다.
- unowned: weak와 유사하게 대상에 대한 참조수를 올리지는 않지만, 해당 객체가 항상 존재한다고 가정한다. 즉, nil 일 수 없으며 nil 값을 참조하게 되면 런타임 오류가 발생하게 된다.
- 참조 수를 올린다?
- ARC:


## ARC
https://outofbedlam.github.io/swift/2016/01/31/Swift-ARC-Closure-weakself/
### reference count
스위프트의 메모리 관리는 참조횟수계산이라는 체계를 기반으로 한다. 참조타입인 클래스 인스턴스를 전달할때 같은 메모리를 가지는 참조가 하나 더 만들어진다. 같은 메모리를 가리키는 참조가 여럿이면 그중 어느 하나라도 지시 대상인 클래스인스턴스가 변경되면 나머지 다른 참조에도 영향을 미친다.
모든 클래스인스턴스는 참조횟수를 가지는데, 이는 클래스 인스턴스를 구성하는 메모리의 참조 개수다. 인스턴스는 참조 횟수가 0보다 큰 동안에는 살아있다고 생각한다. 참조횟수가 0이되는 순간 인스턴스는 회수되며 deinit메서드가 실행된다.

### 강한 참조

클래스 A의 인스턴스, 클래스 B의 인스턴스가 서로를 프로퍼티로 가지는 강한 순환 참조 관계에서는 메모리 릭(leak)이 발생할 수 있다. 이 순환참조에 연관된 객체들은 레퍼런스 카운트가 0에 도닥하지 않고 결국 메모리 누수가 발생한다.
서로 참조하고있는 강한순환참조 관계에서는 각 객체는 자신이 프로퍼티로 속해있는 객체로 인해서 카운트가 계속 유지된다. (레퍼런스 카운트가 0으로 감소할 수 없게 됨) (A객체는 B객체의 프로퍼티가 A이기때문에, B객체는 A객체의 프로퍼티가 B이기때문에, 둘 중 하나만 있어도 둘 다 똑같이 1로 유지됨)

메모리 릭은 인스턴스의 라이프사이클이 끝났음에도(어느곳에서도 변수를 사용하지 않는데) 메모리에 남아있는 것을 말한다.
변수를 선언할 때 strong인지 weak한 참조인지 선언 할 수 있다. 변수 선언은 기본적으로 strong참조이다.
강한 참조는 reference count를 1 올린다.
강한 참조는 참조 카운트를 증가/감소시키고 대상 객체에 대한 참조를 유지해서 순환 참조 문제가 발생할 수 있게 한다.
반대로, 약한 참조weak은 카운트를 변화시키지 않는다. 참조 카운트를 증가시키지 않으면서 객체를 참조할 수 있다.
따라서 강한 참조인경우 변수가 살아있는한, 참조된 값이 메모리에 남아있으리라고 보장할 수 있다. weak의 경우 그 반대이다.

### 강한 순환참조 방지
객체를 변수에 선언할때 레퍼런스에 대한 추가적인 속성을 지정할 수 있다. strong, weak, unowned. (strong이 기본값)
weak - 약한 참조weak은 카운트를 변화시키지 않는다. 참조 카운트를 증가시키지 않으면서 객체를 참조할 수 있다.
unowned- 기본적으로 weak 처럼 대상 객체의 레퍼런스 카운트에 영향을 주지 않는다. 다만 다른 점은 대상 객체가 메모리에서 해제될 때 weak 의 경우에는 nil로 설정되지만 unowned 의 경우에는 값의 변화가 없다. 해당 객체가 항상 존재한다고 가정한다. 즉, nil 일 수 없으며 nil 값을 참조하게 되면 런타임 오류가 발생하게 된다.

weak 약한 참조의 경우에는 소유권을 가지지 않고 단순히 대상 객체를 참조하는 것이므로 대상 객체는 레퍼런스 카운트가 0이 되는 순간 메모리에서 삭제됨. 이때 이 객체를 참조하고 있던 약한 참조 변수는 자동으로 nil이 되어버림. 따라서 약한 참조는 옵셔널 변수에만 가능함. ARC 시스템이 대상 객체의 메모리를 해제한 후에 해당 변수를 nil로 설정해야하기 때문.

반면에 unowned 키워드로 선언하게 되면 ARC 시스템이 대상 객체가 메모리에서 해제될 때 nil로 변경하지 않습니다. 따라서 unowned의 경우에는 옵셔널이 될 수 없습니다.

### 클로저의 순환참조
중요한 이유? 클로저는 레퍼런스형이므로 메모리관리의 대상임.
클로저를 인스턴스 프로퍼티로 선언하여 강한 참조를 만들고 (클로저 -> 인스턴스) 클로저 본문에서 이 인스턴스에 대해 캡쳐하면 순환참조가 발생하게 된다.
클로저 표현식 본문의 코드에서 인스턴스 자체나 그 인스턴스의 다른 프로퍼티를 self.someProperty와 같이 참조 하거나 self.someMethod()와 같이 메서드를 참조하게 되면 해당 대상에 대한 클로저 캡쳐가 발생하게되고, 이는 즉 self를 캡쳐하는 것이고 self와 클로저간의 강한 순환참조가 만들어지는 것.
클로저 내부에서 self를 참조하는 경우 그 self 대상인 인스턴스가 nil이 되어도 계속 참조하게되는 경우가 발생한다.

### 클로저의 캡쳐 리스트 (closure capture list)


궁금한점-프로퍼티가 된다는건 강한 참조관계가 성립한다는뜻? (그런가? 객체가 살아있으면 프로퍼티로 정의된 객체를 계속 참조한다는거니까)
그렇다면 클로저가 a객체의 인스턴스로 있으면 a객체가 살아잇는한 클로저 참조도 살아있다. 강한 참조관계다.라고 할수있는거군
클로저에서 값 캡쳐. self를 쓰게되면 클로저를 선언한/호출한 시점의 해당 인스턴스를 참조하게되는건지? 그래서 클로저안에서 self의 값을 바꿀 수 없는건지. []이렇게 캡쳐해서 쓰면 mutating할 수 없다고 하던데.

## 05-28강-
### 값 / 참조타입
스위프트에서 클래스를 제외한 모든 타입들은 value타입임 (Stack영역)
클래스인 경우는 참조. (Heap영역)

inout / &other - struct 밸류타입도 참조로 쓸 수 있도록 만듦. 하지만 하위호환성을 위해서 사용되는 키워드이고, 밸류타입을 이런식으로 일부러 참조로 쓰도록 권장되진 않는다.

- text: 코드
- gvar/bss: 글로벌변수(클래스 선언 바깥에 있는 변수), static 변수
  - static변수는 복사되지않고 해당 변수를 ㄷ쓰는 곳에 static변수의 주소를 모두 미리 넣어준다
- stack에는 text영역에있는 함수의 위치를 저장한다. (함수 실행 후 끝났을때의 리턴포인트 저장) 함수를 실행하기위한 값(ex. 파라미터 값)들도 복사해서 저장하고 함수 리턴값도 저장함. 그리고 이전의 시작 포인트로 돌아간다. 방금 리턴한 함수를 실행하기위핸 필요한 값이 저장됐던 곳은 다 지워진다.
- heap: heap에 만들어진 (클래스)인스턴스의 주소가 stack에서 변수에 저장됨(주소값을 저장)

- 클래스도 메타데이터를 가지고있는객체라고 생각하기. 클래스도 heap에 로딩됨.(인스턴스를 만들지않았더라 )


- myPen변수는(주소값을가지는) stack에 생김. myPen인스턴스는 heap에생김. NSPen은 heap.
- identity: 인스턴스가 진짜 같은가? (myPen === whichPen)
- equality: 클래스가 같은가? (myPen == yourPen || whichPen == yourPen)

### iOS Memory 앱 강제warning 순서
- 뷰컨트롤러의 func didReceiveMemoryWarning()메소드가 호출되면서 warning을 준다.
(메모리 해제 -> 백그라운드 앱 종료 -> 사용중인 앱 강제종료)


### ARC 레퍼런스 카운트와 릴리즈
- 클래스 인스턴스 입장에서 자신을 참조하는 것들이 몇개인지 세는것
- 인스턴스를 참조하는 변수를 만들고 리턴하면 변수는 없어지지만 해당 변수가 참조하고있던 인스턴스는 자동으로 없어지지 않고, ARC로인해서 레퍼런스 카운팅이 0이되면 heap에서 지워짐

### 소유권
```swift

class Robot : NSObject {
  var name : String
  var nemesis : Robot?
  var model : Int

  override init() {
    name = ""
    nemesis = nil
    model = 0
  }
  deinit {
    print("robot was deinit")
  }
}

var robot1 : Robot? = Robot() // robot1 rc 1 증가
var robot2 : Robot? = Robot() // robot2 rc 1 증가
robot1?.nemesis = robot2 // robot2의 rc 2로 증가
robot2?.nemesis = robot1 // robot1의 rc 2로 증가
robot1 = nil
robot2 = nil
// robot1과 2 인스턴스의 rc는 1
// 상호참조를 하기때문에 참조 카운트는 0이 되지 않고, 메모리에서 해제되지 않음
```

- 클래스의 인스턴스를 참조하고 있는 변수는 값이 아닌 해당 인스턴스의 주소값을 저장하고 있다.
- `robot1 = nil`을 해도 robot1의 인스턴스가 nil이 되는 것이 아니라, robot1 변수에 저장되어있던 인스턴스의 주소값만 nil로 된 것
- `robot2?.nemesis`또한 indirect하게 robot1의 인스턴스를 참조하고있고, 역시 robot1이 가진 주소값을 갖고있다.
- robot1과 2를 nil로 만들면 robot1,2 인스턴스를 찾아가는 주소값이 nil로 없어져(?)버린다.
- 이를 참조하고있던 robot1?.nemesis에서는 robot1을 찾을 수 없게된다.
- 이렇게되면서 robot1과 2는 참조 카운트는 갖고있어서 메모리 상에는 남아있지만 아무 곳에서도 사용하지 않는 메모리 릭이 발생하게된다.   
- 내가 만든 객체가 아닌 객체를 참조해야 할때는 weak키워드를 붙여서 소유권을 갖지 않도록 해야한다.
- 인터페이스빌더에서 IBOutlet을 만들어서 VC에 놓는경우 weak이붙는 이유도 해당 IBOutlet은 인터페이스빌더에 소유권이 있기때문


### 클로저에서 순환참조
```swift
class HTMLElement {

 let name: String
 let text: String?

 lazy var asHTML: () -> String = {
  if let text = self.text {
    return "<\(self.name)>\(text)</\(self.name)>"
  } else {
    return "<\(self.name) />"
  }
 }

 init(name: String, text: String? = nil) {
  self.name = name
  self.text = text
 }

 deinit {
  print("\(name) is being deinitialized")
 }

 }

 var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
 print(paragraph!.asHTML()) // Prints "<p>hello, world</p>"
 paragraph = nil
 print(paragraph?.asHTML()) // nil
 // 인스턴스는 deinit되지 않는다.
```
- 메모리에서 인스턴스가 릴리즈되는 것은 참조 카운트와 관련있다.
- 인스턴스를 참조하는 변수를 nil로 한다고해서 인스턴스가 해제되는 것은 아님 (계속 헷갈렸던 포인트ㅠㅠ . 변수는 인스턴스의 주소값만 가지고있을뿐)
- 클로저에서 self를 사용하는 경우 self에 해당하는 객체와의 strong한 소유 관계(상호참조)가 저절로 생김.....클로저는 캡쳐하기때문
- `var paragraph`를 선언하면서 HTMLElement 인스턴스의 참조카운트가 1로 올라간다.
- `paragraph.asHTML()`로 클로저를 호출하면서 클로저 내부의 self는 paragraph.
- 또한 클로저의 self도 결국은 indirection으로 HTMLElement인스턴스를 참조하게 되면서 참조카운트는 2로 올라간다.
- 그 다음에 `paragraph = nil`하게되면 paragraph변수가 갖고있던 HTMLElement인스턴스의 주소값은 없어지고 참조가 끊어지게된다. 참조카운트는 1.
- paragraph.asHTML()또한 nil값에 접근하게된다. HTMLElement인스턴스를 찾아갈 수 없음.
- 마찬가지로 참조카운트는 1로 남아있는데 인스턴스에 접근할 수 없기때문에 메모리 릭이 발생함.
- paragraph가 nil이 되는것은 단순히 인스턴스의 주소값을 저장해놨던 부분이 없어지는 것일 뿐 인스턴스가 메모리에 남아있고 해제되는 것에는 관련이 없음.

- [unowned self]: self가 클래스인 경우는 캡쳐해도 self를 참조하는 것만 캡쳐되는 것이기때문에 self로 선언된 해당 클래스의 내부 값을 바꿀 수 있다. immutable은 값인 경우!
- (함수에서의 scope개념을 생각하면안됨!)

## autoreleasepool
객체를 내가 만들고 해당 객체를 다른 객체로 넘기고싶은데(retain -> release) 오너십을 옮기는 동안 객체를 보존할 방법
오브젝티브 C - @autoreleasepool
스위프트 - autoreleasepool 클로저. 객체가 자주 많이 생기는 경우에는 autoreleasepool을 사용해야 할때가 있다
