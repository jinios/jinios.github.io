
private func setDoubleTabToCardDeck() {
       let doubleTap = UITapGestureRecognizer(target: self, action: #selector(cardDoubleTapped(sender:)))
       doubleTap.numberOfTapsRequired = 2
       self.subviews.map{ $0.addGestureRecognizer(doubleTap) }
       //addGestureRecognizer(doubleTap)
   }

   @objc func cardDoubleTapped(sender: UITapGestureRecognizer) {
       if sender.state == .ended {
           print("double tapped")
       }
   }

추상화하는법
객체가 가진 값을 외부에서는 몰라야 함 (private)
프로토콜 - 메소드 추상화 - 속성에 직접 접근할 수 없어야함
클래스 상속 - 프로퍼티 추상화


### View와 ViewModel
- View가 protocol을 따르는 객체를 속성으로 갖고있음
- 그 속성은 어떤 객체가 주든 상관없음(VC가될수도, AppDelegate가 될수도있음
- view가 데이터를 직접 가지고(ex. [Beverage]? 혹은 [Card]) 그 인덱스나 밸류값들을 구해서 계산하는게 아니라,
- view가 가진 객체(프로토콜)에게 계속 물어봐서 스스로 그려야함
- 예를들어 pieGraphView가 var history = [Beverage]?를 가지고 총 인덱스 수, 각 밸류의 수, 각도 등을 다 계산해서 그릴것이 아니라
- history = [Beverage]를 가진 객체가 파이그래프를 그리기위해 필요한 각도, 라디안, 총 어레이 카운트 등을 계산해서 가지고있고, pieGraphView가 하나 그릴때마다 객체에 물어보고 스스로 그리는 방식을 써야함. 이때 그린다는 의미는 그릴때의 필요한 정보는(배열의 인덱스, 총 개수, 각 배열의 수 등)view가 하나도 직접 갖고있지않고, 오직 history객체에서 넘겨주는 값을 통해서 draw(add view)만 한다는 뜻이다.
- 여기서 history를 가진 객체는 pieGraphView의 뷰 모델이라고 할 수 있다.


Objective-C
C계열 언어들은 헤더파일이 있다. main에 이런 메소드들이있으니까 보고 써 와 같은 서머리느낌. main에 있는 함수들중에서 public한것만 헤더파일의 @interface 와 @end 사이에 쓴다.
main에서는 헤더를 import해서 쓴다.
import하면 헤더가 복사된

Computer science에서의 atomic - 어떠한 변수나 값에 접근하는 것이 한번에 하나만 되게하는 것이 atomic하다고 말할수있음
누가 쓰고있을때 다른 것이 접근하지 못하게 하는 것(값이 순수하게 유지될 수 있도록 보장)
여러 스레드에서 동시에 하나의 값에 접근하고 사용하는 것(read, write)을 보장하게 하는 것 - atomic
non-atomic 그 반대


Concurrent Programming강의 4/26
https://medium.com/flawless-app-stories/basics-of-parallel-programming-with-swift-93fee8425287

병렬적, 동시성
Parallel - 일을 할 수 있는 worker가 물리적으로 여러개가 있냐 worker들끼리 다 독립적으로 일 할수있어야함 (GPU. 연산에 더 적합)
Concurrent - 논리적으로 작업단위를 나눠서 여러번 처리하는 것이 Concurrent. Concurrent에서 worker는 하나일 수 있다. 하지만 그 작업을 얾마나 나눠서 처리하느냐가 포인트 (CPU. 조건을 판단하고 논리적으로 실행하는 프로그램에 더 적합)
CPU - 프로세서. 이 안에서 논리적인 작업을 하기위해서 쓰레드를만들어서 작업
쓰레드는 맥락(context)을 계속 기억하고있어야 정확히 일을 할 수 있다. 각각의 context가 각각의메모리영역을 갖고, 어디를 실행해야되는지 알고있음
CPU가 많아지면서 앱을 어떤 cpu에서 실행해야할까?가 쟁점이 됨

GCD
운영체제가 알아서 효율적으로 thread를 관리하고, 개발자들은 thread에게 넘길수있는 더 작은 작업단위를(block-클로저단위) 만들어서 thread에 넘기는 형식으로 발전됨 작업을 관리하는 queue에 넣어놓으면 os에의해서 thread가 알아서 작업 처리

thread pool 미리 운영체제가 최적화된 쓰레드풀을미리만들어놓음 - 대기하고있는 객체들을 하나씩 꺼내서 일을 하나씩 주는 형태

Locking
동일한 변수에 여러 쓰레드가 동시에 참조할때 그 부분은 critical section이라고하는데, 이 부분을 atomic하게만들어주기위해 locking하여 동시에 실행되는 것을 막아주는 기능
mutex - mutual execution. 깃발(변수)이 한개 먼저잡은애(worker)가 깃발을 다쓰고 놔둬야 그다음애가 깃발을쓸수있음
semaphor- 리소스가 여러개인경우. (배열처럼, n번째에 온 사람이 n번째의 배열을 쓸수있도록 하는 경우)동시에 쓸수있는사람이 셋인경우 넷인경우 등

멀티쓰레드에서는 데드락을 조심 - 클로저 안에서 다른 클로저가 끝나기를 기다리는 상태
